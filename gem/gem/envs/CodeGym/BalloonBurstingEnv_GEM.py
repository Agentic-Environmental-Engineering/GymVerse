from typing import Any, Dict, Optional, Tuple
import random
import re
from gem.core import Env
from gem.utils.constants import LanguageGameReward


class BalloonBurstingEnvGEM(Env):
    def __init__(
        self,
        complexity: int = 5,  # 难度等级 1-10，默认中等
        enable_param_randomization: bool = False,  # 评估时关闭随机化
        max_turns: Optional[int] = 100,
        **_,  # 忽略其他参数
    ):
        super().__init__()
        self.complexity = complexity
        self.enable_param_randomization = enable_param_randomization
        self.max_turns = max_turns if max_turns is not None else 100

        # 难度参数范围（根据原环境分析）
        self.complexity_params = {
            "array_length": (5, 50),      # 原始气球数组长度
            "value_range": (10, 10000),   # 气球数值范围（正整数）
            "num_constraints": (1, 5),    # 约束条件数量（不直接使用，仅作为难度因素）
        }

        # 参数方差（启用随机化时用于微调参数）
        self.param_variance = {
            "array_length": 2,
            "value_range": 1000,
            "num_constraints": 1,
        }

        # 占位属性
        self.array_length: int = 0
        self.value_range: int = 0
        self.num_constraints: int = 0

        # 原环境的状态变量
        self.original_nums: list[int] = []
        self.nums: list[int] = []
        self.n: int = 0
        self.dp: list[list[int]] = []
        self.current_length: int = 0
        self.current_left: int = 0
        self.current_right: int = 0

        # 统计变量
        self.turn_count: int = 0
        self.step_count: int = 0

        self.reset()

    def _apply_complexity_params(self):
        """根据 complexity 等级计算参数值"""
        normalized = min(1.0, (self.complexity - 1) / 9.0)  # [0, 1]
        for param_name, (min_val, max_val) in self.complexity_params.items():
            center_value = min_val + (max_val - min_val) * normalized
            actual_value = center_value
            if self.enable_param_randomization:
                variance = self.param_variance.get(param_name, 0)
                if variance > 0:
                    actual_value = center_value + random.uniform(-variance, variance)
                    actual_value = max(min_val, min(max_val, actual_value))
            setattr(self, param_name, int(round(actual_value)))

    def _get_instructions(self) -> str:
        return (
            "Balloon Bursting (GEM): Compute the maximum coins by optimally bursting balloons.\n"
            "Array is generated by difficulty. Virtual balloons [1] are added to both ends internally.\n"
            "Available actions (use one per turn, inside \\boxed{...}):\n"
            "- Initialize DP: \\boxed{init}\n"
            "- Set window size: \\boxed{set length L}  (2 <= L <= n-1)\n"
            "- Calculate window max: \\boxed{calc L R I}  (0 <= L < I < R < n)\n"
            "- Get final result: \\boxed{result}\n"
            "- Observe state: \\boxed{observe}\n"
            "- Submit answer: \\boxed{answer N}\n"
        )

    def get_task_suffix(self) -> str:
        base_len = len(self.original_nums)
        return f"Array length: {base_len} | Turn: {self.turn_count}/{self.max_turns} | Enter action."

    def reset(self, seed: Optional[int] = None) -> Tuple[str, Dict[str, Any]]:
        super().reset(seed)
        if seed is not None:
            random.seed(seed)  # 仅影响实例生成

        # 应用难度参数（不受 seed 影响）
        self._apply_complexity_params()

        # 使用难度参数生成问题实例（受 seed 影响）
        self.problem = self._generate_random_problem()

        # 初始化原环境状态
        self.original_nums = self.problem["nums"]
        self.nums = [1] + self.original_nums + [1]
        self.n = len(self.nums)
        self.dp = []
        self.current_length = 0
        self.current_left = 0
        self.current_right = 0

        # 统计变量
        self.turn_count = 0
        self.step_count = 0

        return self._get_instructions(), {"suffix": self.get_task_suffix()}

    def _generate_random_problem(self):
        """根据难度参数随机生成问题实例"""
        nums = [random.randint(1, self.value_range) for _ in range(self.array_length)]
        return {"nums": nums, "size": self.array_length}

    # -------------------------
    # 原环境辅助方法（保留并适配）
    # -------------------------
    def get_ref_answer(self):
        """
        使用环境中的信息计算参考答案（标准 DP 解法）
        """
        nums = [1] + self.original_nums + [1]
        n = len(nums)
        dp = [[0] * n for _ in range(n)]

        for length in range(2, n):
            for left in range(n - length):
                right = left + length
                for i in range(left + 1, right):
                    dp[left][right] = max(
                        dp[left][right],
                        nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right],
                    )
        return dp[0][n - 1]

    def InitializeDP(self) -> str:
        """
        初始化 DP 数组，大小为 n×n
        """
        self.dp = [[0] * self.n for _ in range(self.n)]
        return f"DP array initialized successfully, size is {self.n}×{self.n}"

    def SetWindowSize(self, length: int) -> str:
        """
        设置当前处理窗口的大小
        """
        if length <= 1 or length >= self.n:
            return f"Error: Window size must be greater than 1 and less than {self.n}"
        self.current_length = length
        return f"Window size set successfully, current window size is {length}"

    def CalculateWindowMax(self, left: int, right: int, i: int) -> str:
        """
        计算指定窗口在 i 处最后爆破时的最大收益，并更新 DP
        """
        if not (0 <= left < i < right < self.n):
            return "Error: Invalid index range"
        current_value = (
            self.nums[left] * self.nums[i] * self.nums[right]
            + self.dp[left][i]
            + self.dp[i][right]
        )
        if current_value > self.dp[left][right]:
            self.dp[left][right] = current_value

        self.current_left = left
        self.current_right = right
        return f"The maximum coins for window [{left},{right}] is updated to {self.dp[left][right]}"

    def GetFinalResult(self) -> str:
        """
        获得最终结果（dp[0][n-1]）
        """
        if not self.dp:
            return "Error: DP array has not been initialized"
        return str(self.dp[0][self.n - 1])

    def Observe(self) -> str:
        """
        返回当前环境状态
        """
        dp_status = f"{self.n}×{self.n}" if self.dp else "uninitialized"
        return (
            f"Balloon array: {self.nums}, current window size: {self.current_length}, "
            f"DP array size: {dp_status}"
        )

    def Done(self, answer: int) -> str:
        """
        验证最终答案是否正确
        """
        ref_answer = self.get_ref_answer()
        correct = answer == ref_answer
        msg = (
            f"Your answer: {answer}, Reference answer: {ref_answer}, "
            f"Result: {'Correct' if correct else 'Incorrect'}"
        )
        return msg

    def solve(self) -> str:
        """
        自动完成全部流程，并提交答案
        """
        # init
        obs, _, _, _, _ = self.step("\\boxed{init}")
        # 获取 n
        m = re.search(r"size is (\d+)×(\d+)", obs)
        if m:
            n = int(m.group(1))
        else:
            n = self.n

        # DP
        for length in range(2, n):
            self.step(f"\\boxed{{set length {length}}}")
            for left in range(n - length):
                right = left + length
                for i in range(left + 1, right):
                    self.step(f"\\boxed{{calc {left} {right} {i}}}")

        # result
        obs, _, _, _, _ = self.step("\\boxed{result}")
        try:
            max_coins = int(obs.strip())
        except Exception:
            # 如果 result 未正确返回数字，改用参考答案
            max_coins = self.get_ref_answer()

        # answer
        obs, reward, terminated, truncated, _ = self.step(f"\\boxed{{answer {max_coins}}}")
        return f"{obs}, reward={reward}, terminated={terminated}, truncated={truncated}"

    # -------------------------
    # GEM 必需方法
    # -------------------------
    def step(self, action: str) -> Tuple[str, float, bool, bool, Dict[str, Any]]:
        self.turn_count += 1
        self.step_count += 1

        parsed = self._parse_action(action)
        if not parsed:
            obs = f"Format error at turn {self.turn_count}."
            return (
                obs,
                LanguageGameReward.format_error_reward,
                True,
                False,
                {"suffix": self.get_task_suffix()},
            )

        name = parsed.get("name")
        params = parsed.get("parameters", {})

        terminated = False
        truncated = False
        reward = 0.0
        obs = "Action processed."

        try:
            if name == "init":
                obs = self.InitializeDP()

            elif name == "set_length":
                if "length" not in params:
                    obs = "Error: 'length' parameter is missing for SET_WINDOW_SIZE action."
                    reward = LanguageGameReward.invalid_action_reward
                    terminated = True
                else:
                    msg = self.SetWindowSize(params["length"])
                    obs = msg
                    if msg.startswith("Error:"):
                        reward = LanguageGameReward.invalid_action_reward
                        terminated = True

            elif name == "calc":
                required = all(k in params for k in ("left", "right", "i"))
                if not required:
                    obs = "Error: 'left', 'right' or 'i' parameter is missing for CALCULATE_WINDOW_MAX action."
                    reward = LanguageGameReward.invalid_action_reward
                    terminated = True
                else:
                    msg = self.CalculateWindowMax(params["left"], params["right"], params["i"])
                    obs = msg
                    if msg.startswith("Error:"):
                        reward = LanguageGameReward.invalid_action_reward
                        terminated = True

            elif name == "result":
                msg = self.GetFinalResult()
                obs = msg
                if msg.startswith("Error:"):
                    reward = LanguageGameReward.invalid_action_reward
                    terminated = True

            elif name == "observe":
                obs = self.Observe()

            elif name == "answer":
                if "answer" not in params:
                    obs = "Error: 'answer' parameter is missing for DONE action."
                    reward = LanguageGameReward.invalid_action_reward
                    terminated = True
                else:
                    msg = self.Done(params["answer"])
                    obs = msg
                    ref_answer = self.get_ref_answer()
                    correct = params["answer"] == ref_answer
                    reward = 1.0 if correct else -1.0
                    terminated = True

            else:
                obs = f"Invalid action: {name}"
                reward = LanguageGameReward.invalid_action_reward
                terminated = True

        except Exception as e:
            obs = f"Error: {str(e)}"
            reward = LanguageGameReward.invalid_action_reward
            terminated = True

        # 超时检查（统一放在 step 结尾）
        if not terminated and self.turn_count >= self.max_turns:
            obs = f"{obs}\nReached max turns ({self.max_turns})."
            reward = 0.0
            terminated = True
            truncated = True

        return obs, reward, terminated, truncated, {"suffix": self.get_task_suffix()}

    def _parse_action(self, action: str) -> Optional[Dict]:
        """
        支持以下格式（最后一个 \\boxed{...} 生效）：
        - \\boxed{init}
        - \\boxed{set length L}
        - \\boxed{calc L R I}
        - \\boxed{result}
        - \\boxed{observe}
        - \\boxed{answer N}
        也支持带键名的 calc：
        - \\boxed{calc left L right R i I}
        """
        if not action:
            return None
        pattern = re.compile(r"\\boxed\{(.+?)\}", re.IGNORECASE | re.DOTALL)
        matches = list(pattern.finditer(action))
        if not matches:
            return None
        content = matches[-1].group(1).strip()
        tokens = content.split()

        if len(tokens) == 0:
            return None

        cmd = tokens[0].lower()

        if cmd == "init":
            return {"name": "init", "parameters": {}}

        if cmd == "set" and len(tokens) == 3 and tokens[1].lower() == "length":
            try:
                L = int(tokens[2])
            except Exception:
                return None
            return {"name": "set_length", "parameters": {"length": L}}

        if cmd == "calc":
            # form 1: calc L R I
            if len(tokens) == 4:
                try:
                    L = int(tokens[1])
                    R = int(tokens[2])
                    I = int(tokens[3])
                except Exception:
                    return None
                return {"name": "calc", "parameters": {"left": L, "right": R, "i": I}}
            # form 2: calc left L right R i I
            if len(tokens) == 7 and tokens[1].lower() == "left" and tokens[3].lower() == "right" and tokens[5].lower() == "i":
                try:
                    L = int(tokens[2])
                    R = int(tokens[4])
                    I = int(tokens[6])
                except Exception:
                    return None
                return {"name": "calc", "parameters": {"left": L, "right": R, "i": I}}
            return None

        if cmd == "result" and len(tokens) == 1:
            return {"name": "result", "parameters": {}}

        if cmd == "observe" and len(tokens) == 1:
            return {"name": "observe", "parameters": {}}

        if cmd == "answer" and len(tokens) == 2:
            try:
                ans = int(tokens[1])
            except Exception:
                return None
            return {"name": "answer", "parameters": {"answer": ans}}

        return None

    def sample_random_action(self) -> str:
        # 简单示例动作
        return "\\boxed{observe}"