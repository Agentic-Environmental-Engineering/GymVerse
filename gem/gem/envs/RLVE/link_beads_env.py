from typing import Any, Optional, SupportsFloat, Tuple, List
import random
import networkx
from gem.core import Env
from gem.utils.constants import TERMINAL_STATE


class LinkBeadsEnv(Env):
    """
    Link Beads environment in GEM format.

    Problem:
    You are given a connected undirected graph with N nodes labeled from 0 to N-1, connected by N-1 undirected edges (so this is a tree).
    Each edge is represented as a tuple (u, v, w), meaning there is an undirected edge connecting vertex u to vertex v with weight w.

    These edges are the result of a sequence of operations, each either:
    - Append(x, v): Add a new node x and connect it to an existing node v with a red edge.
    - Insert(x, u, v): Remove the red edge between nodes u and v, and add two blue edges - one from u to x and one from x to v.

    After all operations, the final tree is given, but the edge colors are unknown. Your task is to determine the maximum total length of blue edges
    that could exist in any valid sequence of operations that produces the given graph.

    Output Format: A single integer — the maximum possible total length of blue edges. Your final answer should be a single integer in \\boxed{...}.
    """

    def __init__(
        self,
        fixed_n: Optional[int] = None,
        min_n: int = 3,
        max_n: int = 50,
        **kwargs
    ) -> None:
        """
        Initialize the environment.

        Parameters:
        - fixed_n: If provided, use this fixed number of nodes for every reset (must be >= 3).
        - min_n: Minimum number of nodes when sampling N randomly (inclusive, must be >= 3).
        - max_n: Maximum number of nodes when sampling N randomly (inclusive, must be >= min_n).
        """
        super().__init__()
        if fixed_n is not None:
            assert fixed_n >= 3, "N should be greater than or equal to 3"
        else:
            assert min_n >= 3, "min_n should be greater than or equal to 3"
            assert max_n >= min_n, "max_n should be greater than or equal to min_n"

        self.fixed_n = fixed_n
        self.min_n = min_n
        self.max_n = max_n

        self.current_problem: Optional[str] = None
        self.reference_answer: Optional[int] = None
        self.current_edges: List[tuple[int, int, int]] = []
        self.current_n: Optional[int] = None
        self._total_weight_bound: int = 0

    def _get_instructions(self) -> str:
        """Return task instructions."""
        return (
            "You are given a connected undirected graph (a tree) generated by the following operations:\n"
            "- Append(x, v): Add a new node x and connect it to an existing node v with a red edge.\n"
            "- Insert(x, u, v): Remove the red edge between nodes u and v, and add two blue edges (u-x and x-v).\n"
            "Given only the final tree (edges with weights), determine the maximum possible total length of blue edges\n"
            "over all valid sequences of operations that produce the given tree.\n"
            "Please provide your final answer as a single integer in \\boxed{...} format.\n\n"
        )

    def reset(self, seed: Optional[int] = None) -> Tuple[str, dict[str, Any]]:
        """Reset the environment and generate a new problem instance."""
        super().reset(seed)

        # Determine N
        if self.fixed_n is not None:
            N = self.fixed_n
        else:
            N = random.randint(self.min_n, self.max_n)
        assert N >= 3, "N should be greater than or equal to 3"
        self.current_n = N

        # Generate a random tree with weighted edges
        edges: List[tuple[int, int, int]] = []
        permutations = list(range(N))
        random.shuffle(permutations)
        for index, vertex in enumerate(permutations):
            if index == 0:
                continue
            u, v = vertex, random.choice(permutations[:index])
            u, v = (u, v) if u < v else (v, u)
            edges.append((u, v, random.randint(1, N)))
        random.shuffle(edges)

        for u, v, w in edges:
            assert 0 <= u < v < N
        assert len(edges) == len(set((u, v) for u, v, _ in edges)) == N - 1

        tree = networkx.Graph()
        tree.add_weighted_edges_from(edges)
        assert networkx.is_tree(tree)

        # Solve for the reference answer using DP with rerooting
        reference_answer = self._solve_max_blue_length(N, edges)

        # Build problem text
        edges_text = "\n".join(f"({u}, {v}, {w})" for (u, v, w) in edges)
        problem_text = (
            f"You are given a connected undirected graph with {N} nodes labeled from 0 to {N-1}, "
            f"connected by {N-1} undirected edges (so this is a tree). Each edge is represented as a tuple (u, v, w), "
            f"meaning there is an undirected edge connecting vertex u to vertex v with weight w:\n{edges_text}\n\n"
            "These edges are the result of a sequence of operations, each either:\n"
            "- Append(x, v): Add a new node x and connect it to an existing node v with a red edge.\n"
            "- Insert(x, u, v): Remove the red edge between nodes u and v, and add two blue edges - one from u to x and one from x to v.\n\n"
            "After all operations, the final tree is given (as above), but the edge colors are unknown. Your task is to determine the "
            "maximum total length of blue edges that could exist in any valid sequence of operations that produces the given graph.\n\n"
            "Output Format: A single integer — the maximum possible total length of blue edges.\n"
            "Your final answer should be a single integer in \\boxed{...}."
        )

        self.current_problem = problem_text
        self.reference_answer = reference_answer
        self.current_edges = edges

        # A loose upper bound for sample_random_action
        self._total_weight_bound = sum(w for _, _, w in edges) if edges else 0

        obs = self._get_instructions() + self.current_problem
        return obs, {}

    def _solve_max_blue_length(self, N: int, edges: List[tuple[int, int, int]]) -> int:
        """Compute the maximum possible total length of blue edges."""
        class MultiSetMax:
            def __init__(self):
                # store negatives so that heapq (a min-heap) behaves like a max-heap
                self._add: List[int] = []
                self._rem: List[int] = []

            def insert(self, x: int) -> None:
                import heapq
                heapq.heappush(self._add, -x)

            def remove(self, x: int) -> None:
                import heapq
                heapq.heappush(self._rem, -x)

            def _clean(self) -> None:
                import heapq
                while self._add and self._rem and self._add[0] == self._rem[0]:
                    heapq.heappop(self._add)
                    heapq.heappop(self._rem)

            def get_max(self) -> Optional[int]:
                self._clean()
                if not self._add:
                    return None
                return -self._add[0]

        adj: List[List[tuple[int, int]]] = [[] for _ in range(N)]
        total_weight = 0

        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))
            total_weight += w

        NEG_INF = -(total_weight + 5)

        dp0 = [0] * N
        dp1 = [0] * N
        summ = [0] * N
        st = [MultiSetMax() for _ in range(N)]

        def dfs(x: int, parent: int) -> None:
            for y, w in adj[x]:
                if y == parent:
                    continue
                dfs(y, x)

                v1 = dp0[y]
                if dp1[y] + w > v1:
                    v1 = dp1[y] + w
                v2 = dp0[y] + w

                summ[x] += v1
                st[x].insert(v2 - v1)

            dp0[x] = summ[x]
            m = st[x].get_max()
            dp1[x] = summ[x] + m if m is not None else NEG_INF

        ans = 0

        def dfs0(x: int, parent: int) -> None:
            nonlocal ans
            if dp0[x] > ans:
                ans = dp0[x]

            for y, w in adj[x]:
                if y == parent:
                    continue

                # Backup states
                bx0, bx1, bsx = dp0[x], dp1[x], summ[x]
                by0, by1, bsy = dp0[y], dp1[y], summ[y]

                # Remove y contribution from x
                v1y = dp0[y] if dp0[y] >= dp1[y] + w else dp1[y] + w
                v2y = dp0[y] + w
                delta_xy = v2y - v1y

                st[x].remove(delta_xy)
                summ[x] -= v1y
                dp0[x] = summ[x]
                mx = st[x].get_max()
                dp1[x] = summ[x] + mx if mx is not None else NEG_INF

                # Add x contribution to y
                v1x = dp0[x] if dp0[x] >= dp1[x] + w else dp1[x] + w
                v2x = dp0[x] + w
                delta_yx = v2x - v1x

                summ[y] += v1x
                st[y].insert(delta_yx)
                dp0[y] = summ[y]
                my = st[y].get_max()
                dp1[y] = summ[y] + my if my is not None else NEG_INF

                # Recurse
                dfs0(y, x)

                # Restore states
                dp0[x], dp1[x], summ[x] = bx0, bx1, bsx
                st[x].insert(delta_xy)

                dp0[y], dp1[y], summ[y] = by0, by1, bsy
                st[y].remove(delta_yx)

        dfs(0, -1)
        dfs0(0, -1)
        return ans

    def step(
        self, action: str
    ) -> Tuple[str, SupportsFloat, bool, bool, dict[str, Any]]:
        """Execute one step by validating the provided answer."""
        answer_text = self._parse_answer(action)

        if answer_text is None:
            # Format error: not in \boxed{...}
            return TERMINAL_STATE, -0.1, True, False, {"error": "format_error"}

        try:
            user_answer = int(answer_text)
        except ValueError:
            # Invalid numeric answer
            return TERMINAL_STATE, 0.0, True, False, {"error": "invalid_answer"}

        is_correct = (self.reference_answer is not None and user_answer == self.reference_answer)
        reward = 1.0 if is_correct else 0.0

        info = {
            "correct": is_correct,
            "reference_answer": self.reference_answer,
            "user_answer": user_answer
        }
        return TERMINAL_STATE, reward, True, False, info

    def _parse_answer(self, text: str) -> Optional[str]:
        """Extract the answer inside \\boxed{...}."""
        import re
        pattern = r'\\boxed\{([^}]+)\}'
        matches = re.findall(pattern, text)
        if matches:
            return matches[-1].strip()
        return None

    def sample_random_action(self) -> str:
        """Sample a random action in \\boxed{...} format."""
        # Use a loose bound based on total weights to keep the sample reasonable
        upper = max(0, self._total_weight_bound)
        random_answer = random.randint(0, upper if upper > 0 else 100)
        return f"\\boxed{{{random_answer}}}"