from typing import Any, Optional, SupportsFloat, Tuple, List
import random
from collections import deque
import re

from gem.core import Env
from gem.utils.constants import TERMINAL_STATE


class CardColoringCountingEnv(Env):
    """
    Card Coloring Counting environment (single-turn QA).

    Problem:
    - There are N cards labeled by positions 1..N.
    - K shuffling methods are provided, each a permutation P of {1..N}, where the card at position i moves to position P[i].
    - You need to color exactly R cards red, G cards green, and B cards blue (R + G + B = N).
    - Two colorings are considered the same if one can be transformed into the other by any combination (including repetition) of the available shuffling methods.
    - Compute the number of distinct colorings under this equivalence.

    This environment uses Burnside's lemma by averaging the number of colorings fixed by each permutation in the subgroup generated by the given K permutations.
    """

    def __init__(
        self,
        N: int = 6,
        K: int = 2,
        **kwargs
    ):
        super().__init__()
        assert isinstance(N, int) and N >= 2, "N should be an integer >= 2"
        assert isinstance(K, int) and K >= 0, "K should be an integer >= 0"
        self.N = N
        self.K = K

        # State variables for the current episode
        self.current_problem: Optional[str] = None
        self.reference_answer: Optional[int] = None

        # Problem-specific parameters (populated on reset)
        self.R: Optional[int] = None
        self.G: Optional[int] = None
        self.B: Optional[int] = None
        self.shuffling_methods: Optional[List[List[int]]] = None
        self.subgroup_perms: Optional[List[List[int]]] = None

    def _get_instructions(self) -> str:
        """Return task instructions."""
        return (
            "You are solving a combinatorics problem about counting colorings under shuffling equivalence.\n"
            "Please provide your final answer as a single integer in \\boxed{...} format.\n\n"
        )

    def reset(self, seed: Optional[int] = None) -> Tuple[str, dict[str, Any]]:
        """Reset the environment and generate a new problem instance."""
        super().reset(seed)

        N = self.N
        K = self.K

        # Randomly generate R, G, B such that R + G + B = N
        R = random.randint(0, N)
        remaining = N - R
        G = random.randint(0, remaining)
        B = remaining - G
        RGB = [R, G, B]
        random.shuffle(RGB)
        R, G, B = RGB
        self.R, self.G, self.B = R, G, B

        # Generate K random shuffling methods (permutations)
        selected_perms: List[Tuple[int, ...]] = []
        while len(selected_perms) < K:
            perm = tuple(random.sample(range(1, N + 1), N))
            selected_perms.append(perm)

        # Store shuffling methods as lists (for display)
        self.shuffling_methods = [list(p) for p in selected_perms]

        # Generate subgroup generated by selected_perms
        self.subgroup_perms = self._generate_subgroup(N, selected_perms)

        # Compute reference answer via Burnside's lemma
        self.reference_answer = self._work(N, R, G, B, self.subgroup_perms)
        assert self.reference_answer is not None and self.reference_answer > 0

        # Build the problem text
        shuffles_str = "\n".join(" ".join(map(str, perm)) for perm in self.shuffling_methods)
        self.current_problem = (
            f"You have {N} cards, and there are {K} shuffling methods. Each shuffle method is described by a row of {N} integers: X_1, X_2, ..., X_{N}. "
            f"After applying a shuffle method, the card at position i moves to the position X_i. The shuffling methods are as follows:\n"
            f"{shuffles_str}\n\n"
            f"Now, you need to color these cards into {self.R} red cards, {self.G} green cards, and {self.B} blue cards.\n"
            f"Determine how many distinct coloring schemes exist, where two colorings are considered the same if and only if one can be transformed into the other by any combination of the available shuffling methods (shuffles may be applied multiple times and in any order).\n\n"
            f"Output Format: Your final answer should be a single integer in \\boxed{{...}}."
        )

        obs = self._get_instructions() + self.current_problem
        info: dict[str, Any] = {}
        return obs, info

    def step(self, action: str) -> Tuple[str, SupportsFloat, bool, bool, dict[str, Any]]:
        """Validate the provided answer and return reward."""
        answer_text = self._parse_answer(action)

        if answer_text is None:
            return TERMINAL_STATE, -0.1, True, False, {"error": "format_error"}

        try:
            user_answer = int(answer_text)
        except ValueError:
            return TERMINAL_STATE, 0.0, True, False, {"error": "invalid_answer"}

        assert self.reference_answer is not None
        is_correct = (user_answer == self.reference_answer)
        reward: float = 1.0 if is_correct else 0.0

        info = {
            "correct": is_correct,
            "reference_answer": self.reference_answer,
            "user_answer": user_answer,
            "N": self.N,
            "K": self.K,
            "R": self.R,
            "G": self.G,
            "B": self.B,
            "num_shuffling_methods": len(self.shuffling_methods) if self.shuffling_methods is not None else 0,
            "subgroup_size": len(self.subgroup_perms) if self.subgroup_perms is not None else 0,
        }
        return TERMINAL_STATE, reward, True, False, info

    def _parse_answer(self, text: str) -> Optional[str]:
        """Extract the content inside \\boxed{...} from the model output."""
        pattern = r'\\boxed\{([^}]+)\}'
        matches = re.findall(pattern, text)
        if matches:
            return matches[-1].strip()
        return None

    def sample_random_action(self) -> str:
        """Sample a random action for testing."""
        # Random non-negative integer guess
        guess = random.randint(0, max(1, self.N * self.N))
        return f"\\boxed{{{guess}}}"

    def _generate_subgroup(self, n: int, generators: List[Tuple[int, ...]]) -> List[List[int]]:
        """Generate the subgroup of S_n produced by the given generators (1-based permutations)."""
        def compose(p1: Tuple[int, ...], p2: Tuple[int, ...]) -> Tuple[int, ...]:
            # Compose two permutations (1-based), applying p2 first, then p1
            return tuple(p1[p2[i] - 1] for i in range(n))

        identity = tuple(range(1, n + 1))
        subgroup: set[Tuple[int, ...]] = set()
        queue: deque[Tuple[int, ...]] = deque()

        subgroup.add(identity)
        queue.append(identity)

        for perm in generators:
            if perm not in subgroup:
                subgroup.add(perm)
                queue.append(perm)

        while queue:
            current = queue.popleft()
            for perm in generators:
                composed = compose(current, perm)
                if composed not in subgroup:
                    subgroup.add(composed)
                    queue.append(composed)

        return [list(perm) for perm in subgroup]

    def _solve_single_perm(self, n: int, red: int, blue: int, green: int, v: List[int]) -> int:
        """
        Count the number of colorings fixed by a single permutation v (1-based index),
        with exactly red, blue, green cards of each color. The permutation's cycles
        must be monochromatic, so we count the ways to assign each cycle to a color,
        accumulating cycle lengths to match the desired totals.
        """
        # Cycle detection over 1..n using 1-based permutation v
        visited = [False] * (n + 1)
        cycle_sizes = [0] * (n + 1)
        num_cycles = 0

        for i in range(1, n + 1):
            if not visited[i]:
                x = i
                length = 0
                while not visited[x]:
                    visited[x] = True
                    length += 1
                    x = v[x]
                num_cycles += 1
                cycle_sizes[num_cycles] = length

        # 3D DP: dp[r][b][g] = number of ways
        dp = [[[0 for _ in range(green + 1)] for _ in range(blue + 1)] for _ in range(red + 1)]
        dp[0][0][0] = 1

        for idx in range(1, num_cycles + 1):
            size = cycle_sizes[idx]
            for r in range(red, -1, -1):
                for b in range(blue, -1, -1):
                    for g in range(green, -1, -1):
                        if r >= size:
                            dp[r][b][g] += dp[r - size][b][g]
                        if b >= size:
                            dp[r][b][g] += dp[r][b - size][g]
                        if g >= size:
                            dp[r][b][g] += dp[r][b][g - size]

        return dp[red][blue][green]

    def _work(self, N: int, R: int, G: int, B: int, subgroup_perms: List[List[int]]) -> int:
        """
        Apply Burnside's lemma: average the number of colorings fixed by each permutation
        in the subgroup generated by the provided permutations.
        """
        total_ans = 0
        num_of_perms = len(subgroup_perms)

        for perm_list in subgroup_perms:
            v_current = [0] * (N + 1)
            for idx in range(N):
                v_current[idx + 1] = perm_list[idx]
            total_ans += self._solve_single_perm(N, R, B, G, v_current)

        # Ensure identity is included if it wasn't in the subgroup list (defensive check)
        v_identity = [i for i in range(1, N + 1)]
        if v_identity not in subgroup_perms:
            num_of_perms += 1
            v_identity_full = [0] + v_identity  # 1-based indexing
            total_ans += self._solve_single_perm(N, R, B, G, v_identity_full)

        return total_ans // num_of_perms