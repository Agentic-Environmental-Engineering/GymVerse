from typing import Any, Optional, SupportsFloat, Tuple, List, Dict
import random
from gem.core import Env
from gem.utils.constants import TERMINAL_STATE


class TreeMaximumVisitedVertexEnv(Env):
    """Single-turn environment for the Tree Maximum Visited Vertices problem.

    Task:
      - You are given a tree with N vertices labeled 0..N-1 and a list of N-1 undirected edges.
      - Starting from vertex 0, find a path of exactly M edges that maximizes the number of distinct vertices visited.
      - You may revisit vertices. Output M+1 integers: the sequence of vertices visited.
      - The answer must be provided in \\boxed{v0 v1 v2 ... vM} format (space-separated integers inside the box).

    Reward:
      - Correct (achieves the maximum number of distinct vertices and the path is valid): 1.0
      - Wrong answer (valid format, but suboptimal or invalid path constraints): 0.0
      - Format error (cannot parse boxed content): -0.1
    """

    def __init__(
        self,
        N: Optional[int] = None,
        min_n: int = 3,
        max_n: int = 50,
        **kwargs: Any
    ) -> None:
        """Initialize the environment.

        Parameters:
            N: If provided, the number of vertices in the tree. Must be >= 3.
               If None, N will be sampled uniformly from [min_n, max_n].
            min_n: Minimum possible N when sampling (inclusive). Must be >= 3.
            max_n: Maximum possible N when sampling (inclusive). Must be >= min_n.

        Notes:
            - The path length M is sampled uniformly from [2, 2*(N-1)-1].
            - A random tree is generated by connecting each node (in a random permutation)
              to any one of the previously seen nodes.
        """
        super().__init__()
        if min_n < 3:
            raise ValueError("min_n must be at least 3")
        if max_n < min_n:
            raise ValueError("max_n must be >= min_n")
        if N is not None and N < 3:
            raise ValueError("N must be at least 3 when provided")

        self.fixed_N: Optional[int] = N
        self.min_n: int = min_n
        self.max_n: int = max_n

        # Problem state
        self.N: int = 0
        self.M: int = 0
        self.edges: List[tuple[int, int]] = []
        self.gold_answer: int = 0
        self.current_problem: Optional[str] = None

        # Derived structures for validation
        self._edges_set: set[tuple[int, int]] = set()
        self._adj: List[List[int]] = []

    def _get_instructions(self) -> str:
        """Return general instructions for the task."""
        return (
            "You are solving a tree path optimization problem.\n"
            "Given a tree and a required path length M (in edges), starting from vertex 0, "
            "your goal is to output a valid path of exactly M edges that maximizes the number "
            "of distinct vertices visited at least once. You may revisit vertices. The path "
            "must follow edges in the tree.\n\n"
            "Output Format: Provide M+1 integers (the sequence of vertices) in \\boxed{...}, "
            "space-separated, for example: \\boxed{0 1 2 3}.\n\n"
        )

    def reset(self, seed: Optional[int] = None) -> Tuple[str, Dict[str, Any]]:
        """Reset the environment and generate a new problem instance.

        Returns:
            observation: A string containing instructions and the generated problem.
            info: An empty dictionary for compatibility.
        """
        super().reset(seed)

        # Determine N
        if self.fixed_N is not None:
            self.N = self.fixed_N
        else:
            self.N = random.randint(self.min_n, self.max_n)
        assert self.N >= 3, "N should be greater than or equal to 3"

        # Sample M
        # M in [2, 2*(N-1)-1]
        self.M = random.randint(2, 2 * (self.N - 1) - 1)

        # Generate a random tree
        permutations = list(range(self.N))
        random.shuffle(permutations)
        edges: List[tuple[int, int]] = []
        for index, vertex in enumerate(permutations):
            if index == 0:
                continue
            u, v = vertex, random.choice(permutations[:index])
            u, v = (u, v) if u < v else (v, u)
            edges.append((u, v))
        random.shuffle(edges)

        # Validate tree edges
        for u, v in edges:
            assert 0 <= u < v < self.N
        assert len(edges) == len(set(edges)) == self.N - 1
        self.edges = edges

        # Build adjacency list
        adj: List[List[int]] = [[] for _ in range(self.N)]
        for a, b in self.edges:
            adj[a].append(b)
            adj[b].append(a)
        self._adj = adj

        # Compute gold answer: maximum distinct vertices reachable with M steps from 0
        self.gold_answer = self._compute_gold_answer(self.N, self.M, self._adj)

        # Build edges set for quick validation of steps
        self._edges_set = {(u, v) for (u, v) in self.edges} | {(v, u) for (u, v) in self.edges}

        # Build problem prompt
        edges_str = "\n".join(f"({u}, {v})" for (u, v) in self.edges)
        self.current_problem = (
            f"You are given a tree with {self.N} vertices labeled from 0 to {self.N - 1}. "
            f"The tree has the following {self.N - 1} undirected edges:\n"
            f"{edges_str}\n\n"
            f"Starting from vertex 0, find a path of length {self.M} (i.e., consisting of exactly {self.M} edges) "
            f"that maximizes the number of distinct vertices visited at least once. "
            f"At each step, you can move to any adjacent vertex; you may revisit vertices in the path.\n\n"
            f"Output {self.M} + 1 integers (space-separated) representing the labels of the vertices visited "
            f"along the path, starting from vertex 0.\n\n"
            f"Output Format: Provide your answer in \\boxed{{v0 v1 v2 ... v{self.M}}}."
        )

        obs = self._get_instructions() + self.current_problem
        return obs, {}

    def step(self, action: str) -> Tuple[str, SupportsFloat, bool, bool, Dict[str, Any]]:
        """Validate the submitted path and compute the reward."""
        boxed_content = self._parse_answer(action)
        if boxed_content is None:
            return TERMINAL_STATE, -0.1, True, False, {"error": "format_error"}

        # Parse space-separated integers from boxed content
        try:
            parts = boxed_content.strip().split()
            path = [int(tok) for tok in parts]
        except Exception:
            return TERMINAL_STATE, -0.1, True, False, {"error": "format_error"}

        # Basic validations
        if len(path) != self.M + 1:
            info = {"error": "invalid_solution", "reason": "wrong_length", "expected_length": self.M + 1, "got_length": len(path)}
            return TERMINAL_STATE, 0.0, True, False, info

        if any((v < 0 or v >= self.N) for v in path):
            info = {"error": "invalid_solution", "reason": "vertex_out_of_range"}
            return TERMINAL_STATE, 0.0, True, False, info

        if path[0] != 0:
            info = {"error": "invalid_solution", "reason": "must_start_at_zero"}
            return TERMINAL_STATE, 0.0, True, False, info

        # Check adjacency along the path
        for s, t in zip(path, path[1:]):
            if (s, t) not in self._edges_set:
                info = {"error": "invalid_solution", "reason": "non_adjacent_step", "step": (s, t)}
                return TERMINAL_STATE, 0.0, True, False, info

        # Compute distinct vertices visited
        user_distinct = len(set(path))
        correct = (user_distinct == self.gold_answer)

        reward: float = 1.0 if correct else 0.0
        info = {
            "correct": correct,
            "reference_answer": self.gold_answer,
            "user_distinct": user_distinct,
            "N": self.N,
            "M": self.M,
        }
        return TERMINAL_STATE, reward, True, False, info

    def _parse_answer(self, text: str) -> Optional[str]:
        """Extract the content inside the last \\boxed{...} occurrence."""
        import re
        pattern = r'\\boxed\{([^}]*)\}'
        matches = re.findall(pattern, text, flags=re.DOTALL)
        if matches:
            return matches[-1].strip()
        return None

    def _compute_gold_answer(self, N: int, M: int, adj: List[List[int]]) -> int:
        """Compute the maximum possible number of distinct vertices visited in M steps from node 0."""
        # DFS to compute maximum depth (in nodes) from root 0
        visited = [False] * N
        max_depth_nodes = 0

        def dfs(u: int, depth_nodes: int) -> None:
            nonlocal max_depth_nodes
            visited[u] = True
            max_depth_nodes = max(max_depth_nodes, depth_nodes)
            for v in adj[u]:
                if not visited[v]:
                    dfs(v, depth_nodes + 1)

        dfs(0, 1)

        longest_path_edges = max_depth_nodes - 1
        if M <= longest_path_edges:
            result = M + 1
        else:
            extra = M - longest_path_edges
            result = max_depth_nodes + (extra // 2)
            result = min(N, result)
        return result

    def sample_random_action(self) -> str:
        """Sample a random valid path of length M as a random walk from vertex 0, returned in boxed format."""
        if self._adj is None or len(self._adj) == 0:
            return "\\boxed{}"

        path: List[int] = [0]
        current = 0
        for _ in range(self.M):
            neighbors = self._adj[current]
            # In a tree, every node except root has at least one neighbor
            nxt = random.choice(neighbors)
            path.append(nxt)
            current = nxt

        content = " ".join(str(v) for v in path)
        return f"\\boxed{{{content}}}"